## 람다식 사용법

- 람다식이란?

  람다식은 메서드를 하나의 식(expression)으로 표현한 것으로, 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해준다. 메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 익명 함수라고도 한다.

  메서드의 특징은 클래스에 종속되어있다는 건데, 람다식은 그러한 과정 없이 오직 람다식만으로도 메서드의 역할을 대신할 수 있다. 게다가 람다식은 매개변수로 전달되어지는 것이 가능하고, 메섣의 결과로 반환될 수도 있다. 람다식으로 인해 메서드를 변수처럼 다루는 것이 가능하다는 얘기이다.

- 람다식 작성

  람다식은 익명 함수답게 메서드에서 이름과 반환타입을 제거하고 매개변수 선언부와 몸통 사이에 화살표 연산자를 추가한다.

    ```java
    // 1.
    반환타입 메서드이름(매개변수 선언) {
    	내용
    }

    //2.
    (매개변수 선언) -> { 내용 }

    ```

  1번의 메서드를 2번의 람다식으로 변환이 가능하다. 예로, 삼각형의 넓이를 구하는 공식을 작성한다 한다면,

    ```java
    //삼각형의 넓이는 밑변(b) 곱하기 높이(h) 곱하기 1/2이다.

    //1.
    (int b, int h) -> { return b * h * 0.5; }

    //2.
    (int b, int h) -> b * h * 0.5;

    //3.

    (b, h) -> b * h * 0.5;
    ```

  1번의 경우 맨 처음 예시 그대로 변환한 결과이다. 명시적으로 매개변수의 타입, 리턴까지 사용한 경우를 볼 수 있다.

  2번의 경우 식의 연산 결과가 자동적으로 반환값이 되는 경우이다. 이 때는 문장이 아닌 식이므로 끝에 세미콜론 ';'을 붙이지 않는다.

  3번의 경우 매개변수에 타입이 없는데, 이는 타입이 추론이 가능한 경우에는 생략이 가능하다. 대부분의 경우 생략이 가능하며, 람다식에 반환타입이 없는 이유도 항상 추론이 가능하기 때문이다.

  또한 매개변수가 하나인 경우에는 괄호를 생략할 수 있다. 단, 매개변수의 타입이 있다면 생략해서는 안된다.

    ```java
    // 2제곱의 식
    (int num) -> num * num
    int num -> num * num //에러, 매개변수 부분에 괄호가 생략되었음
    (num) -> num * num
    num -> num * num

    //주석이 없는 부분은 모두 허용된다.
    ```

  중괄호 안의 문장이 한 줄인 경우 중괄호 생략이 가능하다. 단 중괄호 끝에 세미콜론을 붙이지 않아야한다. 또한 return문일 경우 중괄호 생략이 불가능하다.

    ```java
    (int b, int h) -> return b * h * 0.5; //에러, 리턴문에 중괄호가 없음
    (int b, int h) -> { return b * h * 0.5; }; //에러. 중괄호 끝에 세미콜론이 있음

    (int b, int h) -> { return b * h * 0.5; } // 정상 작동
    ```

## 함수형 인터페이스
먼저 람다식은 익명 클래스의 객체와 동등하다. 그렇다면, 람다식으로 정의된 객체를 호출하려면 참조변수가 있어야하는데, 참조변수에 저장하기 위해서는 참조변수의 타입과 일치해야한다. 그리고 람다식과 동등한 메서드가 정의되어 있는 것이여야만이 참조변수로 익명 객체의 메서드를 호출할 수 있게 된다.

람다식도 실제로는 익명 객체이고, 구현하려는 익명 객체의 메서드와 람다식의 매개변수의 타입과 갯수, 그리고 반환값이 일치한다면 익명 객체를 람다식으로 대체가 가능하다.

그러므로, 하나의 메서드가 선언된 인터페이스를 정의해서 람다식을 다루는 것은 기존 자바의 규칙들을 어기지 않으므로 인터페이스를 통해 람다식으로 다루기로 결정되었으며, 람다식을 다루기 위한 인터페이스를 함수형 인터페이스라고 한다.

```java
//1.
public class Test {
    public static void main(String[] args) {
        FI fi = (b, h) -> b * h * 0.5; 
				/*
				FI fi2 = new FI() {
            @Override
            public double getS(int b, int h) {
                return b * h * 0.5;
            }
        };
				*/

        double d = fi.getS(10, 5);
        System.out.println(d); // 25.0
    }
}
//2.
@FunctionalInterface
interface FI {
    double getS(int b, int h);
}
```

먼저 2번을 보면 함수형 인터페이스를 선언 하는 방식에 대해 알 수 있다. 먼저 어노테이션 @FunctionalInterface를 붙이면 컴파일러가 함수형 인터페이스를 올바르게 정의하였는지 확인해준다. 붙이지 않아도 함수형 인터페이스로 사용이 가능하지만, 컴파일러가 확인을 해주니 붙이는 것을 추천한다.

함수형 인터페이스를 선언할 때 주의하여야 할 점은, 함수형 인터페이스는 오직 하나의 추상 메서드만 정의되어 있어야 한다는 제약이 있다. 이는 람다식과 인터페이스의 메서드가 1:1로 연결될 수 있기 때문이다. 그렇기 때문에 추상 메서드는 하나만 정의해야하고, static 메서드와 기본 메서드는 제약이 없다.

1번을 보면 FI 타입의 참조변수 fi를 람다식으로 구현한 코드가 있다. '람다식 사용법'을 보면 어떤 코드인지 알 수 있을 것이다. 1번 블럭 중간 부분에 주석처리된 코드가 세번 째 줄의 코드 한 줄과 같은 역할을 한다.

이처럼 람다식을 사용하면 이전의 익명 메서다식을 사용하면 이전의 더 간결하고 직관적인 코드로 변환이 가능해진다.

- java.util.function

  대부분의 메서드는 타입이 비슷하다. 매개변수가 없거나 많게는 두개, 반환 값은 없거나 하나이다. 또한 제네릭 메서드로 정의하면 매개변수나 반환타입이 달라도 문제가 되지 않는다. 그래서 java.util.function 패키지에 일반적으로 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의해 놓았다.

  |함수형 인터페이스|메서드|설명|
  |---|---|---|
  |java.lang.Runnable|void run()|매개변수도 없고, 반환값도 없음.|
  |Supplier<T>|T get()|매개변수는 없고, 반환값만 있음.|
  |Consumer<T>|void accept(T t)|Supplier와 반대로 매개변수만 있고, 반환값이 없음|
  |Function<T,R>|R apply(T t)|일반적인 함수. 하나의 매개변수를 받아서 결과를 반환|
  |Predicate<T>|boolean test(T t)|조건식을 표현하는데 사용됨. 매개변수는 하나, 반환 타입은 boolean|

  여기서 Predicate와 Function의 차이라면 Predicate는 boolean이라는 것이다. 보통 Predicate는 조건식을 함수로 표현하는데 사용된다.

  매개변수의 개수가 두 개인 함수형 인터페이스는 이름 앞에 'Bi'가 붙는다.

  |함수형 인터페이스|메서드|설명|
  |---|---|---|
  |BiConsumer<T,U>|void accpet(T t, U u)|두 개의 매개변수만 있고, 반환값이 없음|
  |BiPredicate<T,U>|boolean test(T t, U u)|조건식을 표현하는데 사용됨. 매개변수는 둘, 반환값은 boolean|
  |BiFunction<T,U,R>|R apply(T t, U u)|두 개의 매개변수를 받아서 하나의 결과를 반환|

  Supplier는 매개변수는 없고 반환값만 존재하는데, 메서드는 두 개의 값을 반환할 수 없으므로 BiSupplier는 없다.

  Function의 또 다른 변형으로  UnaryOperator와 BinaryOperator가 있는데, 매개변수의 타입과 반환타입의 타입이 모두 일치하는 점만 제외하고는 Function과 같다.

  |함수형 인터페이스|메서드|설명|
  |---|---|---|
  |UnaryOperator<T>|T apply(T t)|Function의 자손, Function과 달리 매개변수와 결과의 타입이 같다.|
  |BinaryOperator<T>|T apply(T t, T t)|BiFunction의 자손, BiFunction과 달리 매개변수와 결과의 타입이 같다.|

## Variable Capture

## 메소드, 생성자 레퍼런스

- 메서드 레퍼런스

메서드 레퍼런스는 static 변수처럼 다룰 수 있게 해준다. 메서드 레퍼런스는 코드를 간략히 하는데 유용해서 많이 사용된다. 다음은 메서드 참조를 이용하여 람다식을 보다 간략하게 만들 수 있는 코드 예제를 보자

```java
import java.util.function.Function;

public class Test {
    public static void main(String[] args) {
        Function<String, Integer> f = Integer::parseInt;
        int num = f.apply("5");
        System.out.println(num); //5

				//Function<String, Integer> f = (String s) -> Integer.parseInt(s);
    }
}
```

메인 메서드 바로 아래 줄의 코드가 메소드 레퍼런스를 이용하여 변경된 메서드이다. 원래라면 주석처리 된 부분처럼 작성할텐데, 메소드 레퍼런스를 이용한다면 더 간결하게 작성 할 수 있다.

위의 메서드 참조에서 람다식의 일부가 생략되었지만, 컴파일러는 생략된 부분을 우항의 parseInt메서드의 선언부로부터, 또는 좌변의 Function 인터페이스에 지정된 제네릭 타입으로부터 쉽게 알아낼 수 있다.

위는 메서드의 종류 별 람다, 메서드 참조방법에 대해 정리된 표이다. 그리고 하나의 메서드만 호출하는 람다식은 '클래스이름::메서드이름' 또는 '참조변수::메서드이름'으로 바꿀 수 있다.

- 생성자 레퍼런스

생성자를 호출하는 람다식도 메서드 참조로 변환할 수 있다.

```java
// 1.
Supplier<MyClass> s = () -> new MyClass(); //람다식
Supplier<MyClass> s = MyClass::new; // 메서드 참조

// 2.
Function<Integer. MyClass> f = (i) -> new MyClass(i); //람다식
Function<Integer. MyClass> f = MyClass::new; //메서드 참조

// 3.
Function<Integer, int[]> f = x -> new int[x]; //람다식
Function<Integer, int[]> f = int[]::new; //메서드 참조
```

1번은 일반적으로 람다식을 메서드 참조로 변환하는 예지이다. 2번은 매개변수가 있는 생성자의 경우, 배열을 생성할때는 3번과 같이 생성자 레퍼런스를 통해 람다식을 구현할 수 있다.

자료참조

자바의 정석 3rd Edition(남궁 성 저)