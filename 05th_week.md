## 클래스 정의하는 방법

일반적으로 툴을 이용하여 클래스를 생성하면 아래와 같은 클래스가 생성된다.

```java
public class Main {

}
```

맨 앞에 보이는 public은 접근제어자로, 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.

|제목|내용|
|---|:---|
|public|접근 제한이 전혀 없다.|
|protected|같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.|
|default|같은 패키지 내에서만 접근이 가능하다.|
|private|같은 클래스 내에서만 접근이 가능하다.|

위의 표를 참고하여 클래스를 정의할 때 접근제어자를 고려해야 한다.

다음 class는 말 그대로 클래스임을 나타내고, Main은 클래스 이름이다.   꼭 지켜야 하는 사항들은 아니지만(비공식 표준), 클래스 이름을 정할 때 주의해야 할 몇가지 사항들이 있다.

1. 스펠링 첫번 째는 대문자로 표시한다.(Main, Example)
2. 명사로 작성한다.(MyDiary(o), Eat(x))
3. 단어가 두개 이상이 각 단어의 첫번 째 스펠링을 대문자로 한다(MyThread, UnitTest)
4. 특수문자 '_', '$' 외에는 사용이 안되며, 첫 문자는 반드시 알파벳으로 시작해야한다.

자료참조

자바의 정석 3rd Edition(남궁 성 저)

## 객체 만드는 방법 (필수, new 키워드 이해하기)

클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며, 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다. 객체와 인스턴스는 같은 의미라고 생각하면 된다.

```java
Main main = new Main();
```

equal 기준 왼쪽의 Main코드를 보면 클래스 타입의 변수를 선언한 것을 볼 수 있다. 이는 정확히 참조 변수라고 하며, 위처럼 참조 변수를 선언하면 참조변수 main을 위한 공간이 메모리 상에 마련된다. 이는 공간만 마련이 되었을 뿐 참조변수로 아무것도 할 수 없다.

그다음 new Main()에 주목해야한다. 이는 메모리 상에 비어있는 main(참조 변수)을 위한 공간에 new 연산자로 인해 Main 클래스의 인스턴스가 생성된다. 다시말해 new 연산자로 하여 빈 메모리 공간에 해당 클래스의 기능을 사용할 수 있도록 설정한 것이다.

부가 설명을 하자면, new 연산자를 통해 메모리에 데이터를 저장 할 공간을 할당받고, 그 공간의 참조값을 객체에게 반환하고나서 생성자를 호출하게된다. 그러므로 선언할 때 new라는 연산자로 인해 참조 변수에 실제 데이터가 아닌, 참조값을 갖는다.

자료참조

자바의 정석 3rd Edition(남궁 성 저)

[https://m.blog.naver.com/PostView.nhn?blogId=heartflow89&logNo=220955262405&proxyReferer=https:%2F%2Fwww.google.com%2F](https://m.blog.naver.com/PostView.nhn?blogId=heartflow89&logNo=220955262405&proxyReferer=https:%2F%2Fwww.google.com%2F)

## 메소드 정의하는 방법(필수)

메서드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것으로, 수학의 함수와 유사하다.

메서드를 정의하기 전, 선언과 구현을 나누어야한다. 일단 밑의 코드를 보면,

```java
public void myDiary(String msg) { //선언부
	// 구현부
}
```

위의 public은 접근제한자로, 위의 표를 통해 확인하면 된다. 그다음 void는 반환 타입으로 반환값이 없으면 void를 입력하고, 반환 값이 있다면, 반환 값의 타입을 입력하면 된다. 예를들어, 반환 타입이 String이라면,

```java
public String myDiary(String msg) {
	// 구현부
	return str;
}
```

반환 타입이 있다면 반드시 구현부 안에는 return으로 반환할 값을 정해야한다. 대신 반드시 선언부의 타입에 맞는 값을 입력해야한다.

그 다음은 myDiary로 메서드 이름을 입력했다. 처음 시작은 소문자로, 그 다음 단어부터는 첫 이니셜에 대문자를 입력한다. 이는 붙어있는 단어들을 구분하여 볼 수 있도록 하기 위함이다. 카멜 표기법이라고도 불리는데 더 자세한 내용은 [링크](https://ko.wikipedia.org/wiki/%EB%82%99%ED%83%80_%EB%8C%80%EB%AC%B8%EC%9E%90)를 통해 확인할 수 있다.

다음은 구현부이다. 구현부는 선언부를 마치면 중괄호가 있는데, 그 중괄호 안에서 구현부를 작성하면 된다.

자료참조

자바의 정석 3rd Edition(남궁 성 저)

## 생성자 정의하는 방법(필수)
생성자는 클래스의 구현부에서 정의가 가능하며, 메서드와 구조가 유사하다. 하지만 그 중 가장 큰 차이점 두개를 꼽자면, 리턴값이 없다는 것과 생성자의 이름은 반드시 클래스명으로 해야한다는 것이다. 생성자는 아래의 코드와 같다.

```java
public class Main {
	public Main() {
		...
	}
}

```

클래스 안에 정의 되어 있는 것이 생성자이다. 생성자의 큰 특징 중 하나는 오버로딩이 가능하다는 것이다. 그 말은 매개변수가 없는 생성자를 만들 수 있고, 매개변수가 있는 생성자 또한 만들 수 있다.

이는 기본 생성자와 매개변수가 있는 생성자로 나눌 수 있다.

- 기본 생성자(default constructor)

  위의 코드와 같은 생성자를 기본 생성자라고 한다. 매개변수가 없고, 구현부 또한 내용이 없다(꼭 없어야 하는 건 아니지만 보통 없는 편이다). 보통 클래스를 생성하면 구현부에 아무 내용도 없지만 사실은 기본 생성자가 기본 기능으로 제공된다. 이는 클래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유이기도 하다.

  기본생성자를 만드는 코드는 위의 코드와 같으니 생략하겠다.

- 매개변수가 있는 생성자

  기본 생성자와는 반대로 매개변수가 있고, 구현부에 내용이 있다. 아래의 코드를 먼저 보자.

    ```java
    public class Main {
    	//필드 변수 설정
    	private String name;
    	private int age;

    	public Main(String name, int age) { // 매개변수가 있는 생성자
    			this.name = name; // 매개변수를 필드의 변수로 대입
    			this.age = age; // 매개변수를 필드의 변수로 대입
    	}
    }
    ```

  중간에 매개변수가 있는 생성자를 생성하였다. String 타입의 이름과, int 타입의 나이를 매개변수로 설정하였다. 매개변수가 있는 생성자를 사용하는 이유는 객체 생성과 동시에 원하는 값으로 초기화가 가능하기 때문이다.

    ```java
    public class MainTest {
    	public static void main(String[] args) {
    		Main main = new Main("Park-Sil", 27); //name = "Park-Sil", age = 27
    	}
    }
    ```

  다른 클래스에서 새로운 객체를 생성했다. 이전과 다른 점이라면 생성자 부분의 파라미터에 값이 있다는 것이다. 기본생성자만 있었다면 에러가 발생했을 텐데 Main 클래스의 매개변수가 있는 생성자로 인해 새로운 객체 생성이 가능할 수 있게 됐다.

  이로써 매개변수가 있는 생성자를 통해 간결하고 직관적인 코드로 바꿀 수 있다.

자료참조

자바의 정석 3rd Edition (남궁 성 저)

## this 키워드 이해하기(필수)

Java에서 this 키워드를 사용 할 때는 크게 두가지로 나눌 수 있다. 생성자 내에서 생성자를 호출 할 때와 자기 자신을 가리킬 때의 this로 나눈다.

- 생성자 내에서 생성자를 호출할 때

  먼저 코드로 예시를 들어보겠다.

    ```java
    public class Main{
    	String name;
    	int age;

    	public Main() {
    		this("Park-Sil", 27);
    	}

    	public Main(String name) {
    		this(name, 27);
    	}
    }
    ```

  생성자의 구현부에 this 라는 키워드를 볼 수 있다. 이는 Car를 대신하는 것으로 만약 Car라고 적는다면 에러가 뜬다. 이유는 this를 입력하지 않았기 때문이다. 만약 Car라고 적는다면 'Method call expected' 라는 에러메세지가 호출된다.

  그리고 this 키워드를 사용하기 전에 매개변수가 있는 생성자가 생성되었는지 확인 하는것도 중요한 부분이다.

- 자기 자신을 가리킬 때

    ```java
    public class Main {
    	//필드 변수 설정
    	private String name;
    	private int age;

    	public Main(String name, int age) { // 매개변수가 있는 생성자
    			this.name = name; // 매개변수를 필드의 변수로 대입
    			this.age = age; // 매개변수를 필드의 변수로 대입
    	}
    }
    ```

  생성자의 구현부를 보면 가운데의 이콜(equal, '=')을 기준으로 왼쪽은 변수를, 오른쪽은 매개변수를 뜻한다. 양쪽의 이름이 같기 떄문에 혼란을 일으킬 수 있어 지역변수 앞에 this를 이용하면 된다. 만약 this 키워드를 붙이지 않는다면 둘 다 지역변수로 간주되니 그 점은 유의해야 한다.

  이러한 규칙을 지키면 클래스 내의 생성자들은 일반적으로 서로 관계가 깊은 경우가 많아서 이처럼 서로 호출하도록 하여 유기적으로 연결해주면 더 좋은 코드를 얻을 수 있다. 그리고 수정이 필요한 경우에도 보다 적은 코드을 변경하면 되므로 유지보수가 쉽다는 장점이 있다.

자료참조

자바의 정석 3rd Edition(남궁 성 저)

## int 값을 가지고 있는 이진 트리를 나타내는 Node 라는 클래스를 정의하세요.(선택)

## int value, Node left, right를 가지고 있어야 합니다.(선택)

## BinrayTree라는 클래스를 정의하고 주어진 노드를 기준으로 출력하는bfs(Node node)와 dfs(Node node) 메소드를 구현하세요.(선택)

## DFS는 왼쪽, 루트, 오른쪽 순으로 순회하세요.(선택)